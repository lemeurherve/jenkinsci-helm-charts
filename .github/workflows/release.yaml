name: Release Charts

on:
  push:
    branches:
      - main

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "$GITHUB_ACTOR"
          git config user.email "$GITHUB_ACTOR@users.noreply.github.com"

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.12.0

      - name: Run chart-releaser
        id: chart_releaser
        uses: helm/chart-releaser-action@v1.6.0
        # with:
        #   config: cr.yaml
        env:
          CR_TOKEN: "${{ secrets.GITHUB_TOKEN }}"

      - name: Dump All Outputs
        run: |
          echo "${{ toJson(steps.chart_releaser.outputs) }}"

      # Retrieve last tag pushed by cr
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get Last Tag
        id: last_tag
        run: echo "tag=$(git describe --abbrev=0 --tags)" >> "${GITHUB_OUTPUT}"

      - name: Display Last Tag
        run: |
          echo "Last Tag: ${{ steps.last_tag.outputs.tag }}"
      - name: Display Last cr version
        run: |
          echo "Last chart_version: ${{ steps.chart_releaser.outputs.chart_version }}"


      ## Retrieve the current description and id of the release from its tag

      - name: Extract last tag changelog
        id: last_tag_changelog
        # if: steps.chart_releaser.outputs.changed_charts != ''
        env:
          LAST_TAG: ${{ steps.last_tag.outputs.tag }}
        run: |
          changelog=$(awk -v tag=${LAST_TAG#jenkins-} '
          /^(##|###) [0-9]+.[0-9]+.[0-9]+/ {
              if (p) { exit };
              if ($2 == tag) {
                  p = 1; next
              }
          } p
          ' charts/jenkins/CHANGELOG.md)
          echo "Changelog for ${LAST_TAG#jenkins-}:"
          echo "$changelog"    

          delimiter="$(openssl rand -hex 8)"
          echo "changelog<<${delimiter}" >> "${GITHUB_OUTPUT}"
          echo "${changelog}" >> "${GITHUB_OUTPUT}"
          echo "${delimiter}" >> "${GITHUB_OUTPUT}"

      - name: Retrieve release info
        id: release_info
        env:
          LAST_TAG: ${{ steps.last_tag.outputs.tag }}
          REPOSITORY: ${{ github.repository }}
        run: |
          echo "REPOSITORY: $REPOSITORY"
          echo "LAST_TAG: $LAST_TAG"
          release=$(curl -L \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${REPOSITORY}/releases/tags/${LAST_TAG})

          body=$(echo $release | jq '.body')
          id=$(echo $release | jq '.id')

          echo "release: $release"

          delimiter="$(openssl rand -hex 8)"
          echo "body<<${delimiter}" >> "${GITHUB_OUTPUT}"
          echo "${body}" >> "${GITHUB_OUTPUT}"
          echo "${delimiter}" >> "${GITHUB_OUTPUT}"
          echo "id=${id}" >> "${GITHUB_OUTPUT}"

      - name: Display release body
        run: |
          echo "Body: ${{ steps.release_info.outputs.body }}"
          echo "Id: ${{ steps.release_info.outputs.id }}"

      - name: Update release description
        id: update_release
        # if: steps.chart_releaser.outputs.changed_charts != ''
        uses: actions/github-script@v6
        env:
          ID: ${{ steps.release_info.outputs.body }}
          BODY: ${{steps.release_info.outputs.id}}
          CHANGELOG: ${{steps.last_tag_changelog.outputs.changelog}}
        with:
          script: |
            console.log("last_tag:")
            console.log(process.env.LAST_TAG)
            console.log("changelog:")
            console.log(process.env.CHANGELOG)

            try {

              updatedBody = process.env.BODY + "\r\n---\r\n" + process.env.CHANGELOG

              console.log(updatedBody)

              // await github.rest.repos.updateRelease({
              //   id: currentRelease.id,
              //   owner: context.repo.owner,
              //   repo: context.repo.repo,
              //   body: updatedBody,
              // });
            } catch (error) {
              core.setFailed(error.message);
            }
# curl -L \
#   -H "Accept: application/vnd.github+json" \
#   -H "Authorization: Bearer $GH_TOKEN" \
#   -H "X-GitHub-Api-Version: 2022-11-28" \
#   https://api.github.com/repos/{{ github.repository }}/releases/tags/jenkins-5.1.36


      # - name: "Generate markdown from current and next milestone"
      #   id: milestones_as_markdown
      #   uses: actions/github-script@v6
      #   with:
      #     result-encoding: string
      #     script: |
      #       const getMilestoneAsMarkdown = async function(milestone, milestoneName, issuesState, closeReason) {
      #         const opts = github.rest.issues.listForRepo.endpoint.merge({
      #           ...context.issue,
      #           milestone,
      #           state: issuesState,
      #           sort: 'updated',
      #           per_page: 100,
      #         })
      #         const issues = await github.paginate(opts)

      #         let markdown = ''
      #         let category = (closeReason == 'completed') ? 'Done' : 'Closed as not planned'
      #         let query = '?closed=1'

      #         // There should not be any closed issue in the 'next' milestone, only 'Done' ones
      #         if (issuesState == 'open') {
      #           category = (milestoneName != 'next') ? 'Work In Progress' : 'Backlog'
      #           if (milestoneName == 'todo') category = 'TODO (next milestone)'
      #           query = ''
      #         }

      #         title = `* [${category}](${context.payload.repository.html_url}/milestone/${milestone}${query}):`

      #         if (issues.length > 0) {
      #           for (const issue of issues) {
      #             if ((issuesState == 'open') || ((issuesState == 'closed') && (issue.state_reason == closeReason))){
      #               markdown = markdown.concat("\r\n").concat(`  * [${issue.title}](${issue.html_url})`)
      #             }
      #           }
      #         }
              
      #         if (markdown != '') markdown = title.concat("\r\n").concat(markdown)
              
      #         return markdown
      #       }

      #       done = await getMilestoneAsMarkdown(context.payload.inputs.milestone_id, context.payload.inputs.milestone_name, 'closed', 'completed')
      #       notPlanned = await getMilestoneAsMarkdown(context.payload.inputs.milestone_id, context.payload.inputs.milestone_name, 'closed', 'not_planned')
      #       wip = await getMilestoneAsMarkdown(context.payload.inputs.milestone_id, context.payload.inputs.milestone_name, 'open', '')
      #       try {
      #         todoMilestone = parseInt(context.payload.inputs.milestone_id) + 1
      #         todo = await getMilestoneAsMarkdown(todoMilestone, 'todo', 'open', '')
      #       } catch (error) {
      #         console.error(error);
      #         todo = ''
      #       }
      #       next = await getMilestoneAsMarkdown(context.payload.inputs.next_milestone_id, context.payload.inputs.next_milestone_name, 'open', '')

      #       return `Markdown for the infra team sync meeting notes preparation:
      #       <pre><code>
      #       ${done}

      #       ${notPlanned}

      #       ${wip}

      #       ${next}
      #       </code></pre>

      #       <details><summary>Preview:</summary>

      #       ${done}
            
      #       * New items:
      #           * placeholder 1
      #           * placeholder 2
            
      #       ${wip}

      #       ${todo}

      #       <!--
      #       ${next}
      #       -->

      #       </details>

      #       Generated from the ["${context.payload.inputs.milestone_name}"](${context.payload.repository.html_url}/milestone/${context.payload.inputs.milestone_id}) and the ["${context.payload.inputs.next_milestone_name}"](${context.payload.repository.html_url}/milestone/${context.payload.inputs.next_milestone_id}) milestones.`

      # - name: "Create release"
      #   id: create_release
      #   uses: actions/github-script@v6
      #   env:
      #     CURRENT_DATE: ${{ steps.date.outputs.date }}
      #     RELEASE_BODY: ${{steps.milestones_as_markdown.outputs.result}}
      #   with:
      #     script: |
      #       name = `infra-team-sync-${process.env.CURRENT_DATE}`
      #       tag = `${name}_${context.runNumber}`

      #       try {
      #         await github.rest.repos.createRelease({
      #           name: name,
      #           owner: context.repo.owner,
      #           repo: context.repo.repo,
      #           body: process.env.RELEASE_BODY,
      #           tag_name: tag,
      #           draft: true,
      #           generate_release_notes: true,
      #           prerelease: false,
      #         });
      #       } catch (error) {
      #         core.setFailed(error.message);
      #       }
